---
description: 也涵盖 Signature adaptors 签名适配器与 Scriptless scripts 无脚本签名
---

# Adaptor signatures 适配器签名

**适配器签名**（也称为**签名适配器**）是承诺一个隐藏值的辅助签名数据。当一个适配器与相应的签名组合时，它会展示隐藏值。或者，当与隐藏值组合时，适配器会展示签名。其他人可以创建重复使用承诺的二级适配器，即使他们不知道隐藏值。这使得适配器成为实现比特币合约锁定的强大工具。

在比特币的合约中，通常需要一个锁定机制来确保一组支付的原子性——要么所有支付都成功，要么都失败。这种锁定传统上通过让集合中的所有支付承诺相同的哈希摘要原像实现；当知道原像的一方在链上展示它时，其他人都知道它并可以解锁他们自己的支付。在比特币中常用的 _哈希锁_ 消耗大约 67 字节，并且展示了一组支付之间的联系，因为它们都使用相同的原像和摘要。

相比之下，签名适配器永远不需要在链上发布。对于没有相应适配器的人来说，使用适配器创建的签名看起来就像其他任何数字签名一样，使得适配器相对哈希锁在效率和隐私方面都具有显著优势。

## 示例

在简单的货币交换协议中可以看到签名适配器的多种用途。例如，Alice 可以给 Bob 一个承诺支付给他1个比特币的未签名交易的适配器。适配器本身不能用作BIP340签名，所以Alice还没有支付给Bob。

适配器为Bob提供对Alice隐藏值的承诺。这个承诺包括一个Bob可以用来创建二级适配器的参数，二级适配器与Alice的适配器承诺相同的隐藏值。即使Bob不知道Alice的隐藏值或Bob自己对该承诺的签名，他也可以做出那个承诺。Bob给Alice他的二级适配器和一个相应的未签名交易，承诺支付给她1个比特币。

Alice一直知道隐藏值，所以她可以结合隐藏值与Bob的适配器，得到支付给她的交易的Bob的签名。她广播交易并收到Bob的支付。当Bob在链上看到那笔交易时，他可以结合交易的签名与他给Alice的二级适配器，得到隐藏值。然后他可以结合隐藏值与Alice更早给他的适配器。Bob广播那笔交易，接收Alice的支付，完成货币交换。

除了货币交换，还有几个其他的适配器签名的[建议用途](https://github.com/ElementsProject/scriptless-scripts)。

_点击以数学术语显示相同的货币交换示例_

_在以下示例中，我们假设使用BIP340 schnorr签名。我们使用小写变量表示标量，大写变量表示椭圆曲线点。我们用`||`表示连接，用`H()`表示哈希函数。_ Alice使用她的私钥(`p`)创建一个有效签名承诺(`s`)，为给Bob的交易支付(`m`)，她的私钥对应公钥是(`P = pG`)。她还使用私有随机nonce(`r`)、隐藏值(`t`)以及它们的椭圆曲线点(`R = rG, T = tG`):

`s = r + t + H(R + T || P || m) * p`

她从签名承诺中减去`t`来产生签名适配器:

`s' = s - t`

她给Bob这个适配器，它包含以下数据:

`s', R, T`

Bob可以验证适配器:

`s' * G ?= R + H(R + T || P || m) * P`

但适配器不是有效的BIP340签名。对于有效签名，BIP340 期望`x`和`Y`，并用在表达式：

`x * G ?= Y + H(Y || P || m) * P`

但是，

* 如果Bob设置`Y = R`以匹配他在适配器中收到的`s'`，那么BIP340会在`H(R || P || m)`上失败，因为Alice是用`H(R + T || P || m)`来计算她的哈希的。
* 如果Bob设置`Y = R + T`以匹配`H(R + T || P || m)`，BIP340会在最初的`Y`上失败，因为Bob提供的是`R + T`而不是需要的`R`。

因此Bob不能使用适配器作为BIP340签名。然而，他可以使用它创建自己的适配器。这与Alice创建的签名类似，但Bob在这里不承诺`t`，因为Bob不知道那个值。除了`T`之外，此处所有变量对于Bob与对于Alice都不同：

`s = r + H(R + T || P || m) * p`

与Alice不同，Bob不需要调整签名。Bob的签名承诺`s`不是有效签名的一部分，因为它承诺`r`和`R + T`，这不会通过BIP340验证，原因与前面描述的相同。要想签名有效，签名需要承诺`r + t`和`R + T`，而Bob不能产生这个承诺，因为他不知道`t`。Bob给Alice他的适配器:

`s, R, T`

Alice已经知道了`T`，但`(s, R, T)`是标准的签名适配器，所以我们使用它的完整形式。Alice可以使用只有她一直知道的隐藏值`t`从适配器中产生签名:

`(s + t) * G ?= R + T + H(R + T || P || m) * P`

Alice使用签名广播Bob支付给她的交易。当Bob在链上看到`(s + t)`时，他可以知道`t`的值:

`t = (s + t) - s`

然后，他可以使用`t`来解决Alice更早给他的适配器：

`(s' + t) * G ?= R + T + H(R + T || P || m) * P`

Bob使用那个签名广播Alice最初给他的交易。

## 与多方签名的关系

签名适配器通常不能完全独立地保证合约的安全性。例如，在上面描述的货币交换中，Alice在知道Bob的签名后可以双重花费，或者Bob也可以尝试相同的操作（会更困难，因为我们假定Alice的交易有一个确认）。这个问题通常结合签名适配器与多方签名解决。例如，Alice将她的钱存入一个地址，只有当她和Bob合作创建有效签名时才能花费。现在Alice可以为她一半的多方签名提供适配器给Bob，Bob知道Alice不能在没有他参与的情况下双重花费资金，所以能完全安全地接受适配器。这可能还需要限时退款选项，以防某一方拒绝签名。

在[schnorr签名方案](https://bitcoinops.org/en/topics/schnorr-signatures/)中，签名适配器通常被提议结合多方签名方案如[MuSig](https://bitcoinops.org/en/topics/musig/)，以允许发布的签名看起来像一个单方签名，从而增强隐私和效率。这在ECDSA中也是可能的，但它需要新的算法，要么相对较慢，要么需要额外的安全假设。作为替代，比特币的适配器签名有[备选方案](https://github.com/LLFourn/one-time-VES/blob/master/main.pdf)，它使用2-of-2的`OP_CHECKSIG`多签；这样效率较低且可能隐私较差——但按理是比多方ECDSA更简单和安全的。
